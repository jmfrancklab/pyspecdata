

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>N-dimensional Data (nddata) &mdash; pySpecData 0.9.5.3.2 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/gallery_custom.css" type="text/css" />
  <link rel="stylesheet" href="_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="_static/gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="_static/gallery-dataframe.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Axis Manipulation Functions" href="axis_manipulation.html" />
    <link rel="prev" title="LaTeX Notebook Functionality" href="notebook.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> pySpecData
          

          
          </a>

          
            
            
              <div class="version">
                0.9.5.3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="modules.html">List of Modules and Sub-Packages</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="notebook.html">LaTeX Notebook Functionality</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="notebook.html#setting-up-the-notebook">Setting up the notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebook.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebook.html#running-the-notebook">Running the notebook</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="notebook.html#how-it-works">How it works</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="notebook.html#the-latex-end">The LaTeX end</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="notebook.html#the-python-end">The python end</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">N-dimensional Data (nddata)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#full-list-of-nddata-methods">Full list of <cite>nddata</cite> methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="latexscripts.html">Documentation of Notebook Helper Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nddata.html">ND-Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="fitdata.html">the fitdata class</a></li>
<li class="toctree-l1"><a class="reference internal" href="figlist.html">The Figure List</a></li>
<li class="toctree-l1"><a class="reference internal" href="units.html">Units</a></li>
</ul>
<p class="caption"><span class="caption-text">Example Gallery</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">PySpecData Examples</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pySpecData</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="notebook.html">LaTeX Notebook Functionality</a> &raquo;</li>
        
      <li>N-dimensional Data (nddata)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/pyspecdata.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="n-dimensional-data-nddata">
<h1>N-dimensional Data (nddata)<a class="headerlink" href="#n-dimensional-data-nddata" title="Permalink to this headline">¶</a></h1>
<div class="section" id="by-topic">
<h2>By Topic<a class="headerlink" href="#by-topic" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="axis_manipulation.html">Axis Manipulation Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="fourier.html">Fourier Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="nddata.html">ND-Data</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="full-list-of-nddata-methods">
<h1>Full list of <cite>nddata</cite> methods<a class="headerlink" href="#full-list-of-nddata-methods" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="pyspecdata.nddata">
<em class="property">class </em><code class="sig-prename descclassname">pyspecdata.</code><code class="sig-name descname">nddata</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the detailed API reference.
For an introduction on how to use ND-Data, see the <a class="reference internal" href="nddata.html#nddata-summary-label"><span class="std std-ref">Main ND-Data Documentation</span></a>.</p>
<dl class="py method">
<dt id="pyspecdata.nddata.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize nddata – several options.
Depending on the information available, one of several formats can be used.</p>
<dl class="simple">
<dt>3 arguments:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nddata(inputarray,</span> <span class="pre">shape,</span> <span class="pre">dimlabels)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">inputarray</dt>
<dd class="field-odd"><p>np.ndarray storing the data – note that the size is ignored
and the data is reshaped as needed</p>
</dd>
<dt class="field-even">shape</dt>
<dd class="field-even"><p>a list (or np.array, <em>etc.</em>) giving the size of each dimension, in order</p>
</dd>
<dt class="field-odd">dimlabels</dt>
<dd class="field-odd"><p>a list giving the names of each dimension, in order</p>
</dd>
</dl>
</dd>
<dt>2 arguments:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nddata(inputarray,</span> <span class="pre">dimlabels)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">inputarray</dt>
<dd class="field-odd"><p>np.ndarray storing the data – the data is <em>not</em> reshaped</p>
</dd>
<dt class="field-even">dimlabels</dt>
<dd class="field-even"><p>a list giving the names of each dimension, in order</p>
</dd>
</dl>
</dd>
<dt>2 arguments:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nddata(inputarray,</span> <span class="pre">single_dimlabel)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">inputarray</dt>
<dd class="field-odd"><p>np.ndarray storing the data – must be 1D
inputarray is <em>also</em> used to label the single axis</p>
</dd>
<dt class="field-even">single_dimlabel</dt>
<dd class="field-even"><p>a list giving the name of the single axis</p>
</dd>
</dl>
</dd>
<dt>1 argument:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nddata(inputarray,</span> <span class="pre">shape,</span> <span class="pre">dimlabels)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">inputarray</dt>
<dd class="field-odd"><p>np.ndarray storing the data – reduced to 1D
A single dimension, called “INDEX” is set.
This suppresses the printing of axis labels.
This is used to store numbers and arrays
that might have error and units,
but aren’t gridded data.</p>
</dd>
</dl>
</dd>
<dt>keyword args</dt><dd><p>these can be used to set the labels, etc, and are passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">__my_init__()</span></code></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.__init__" title="pyspecdata.nddata.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(*args, **kwargs)</p></td>
<td><p>initialize nddata – several options.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.add_noise" title="pyspecdata.nddata.add_noise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_noise</span></code></a>(intensity)</p></td>
<td><p>Add Gaussian (box-muller) noise to the data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.aligndata" title="pyspecdata.nddata.aligndata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aligndata</span></code></a>(arg)</p></td>
<td><p>This is a fundamental method used by all of the arithmetic operations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.argmax" title="pyspecdata.nddata.argmax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmax</span></code></a>(*args, **kwargs)</p></td>
<td><p>find the max along a particular axis, and get rid of that axis, replacing it with the index number of the max value</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.argmin" title="pyspecdata.nddata.argmin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argmin</span></code></a>(*axes, **kwargs)</p></td>
<td><p>If <cite>np.argmin(‘axisname’)</cite> find the min along a particular axis, and get rid of that axis, replacing it with the index number of the max value.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.angle" title="pyspecdata.nddata.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a></p></td>
<td><p>Return the angle component of the data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.axis" title="pyspecdata.nddata.axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axis</span></code></a>(axisname)</p></td>
<td><p>returns a 1-D axis for further manipulation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.axlen" title="pyspecdata.nddata.axlen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axlen</span></code></a>(axis)</p></td>
<td><p>return the size (length) of an axis, by name</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.axn" title="pyspecdata.nddata.axn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axn</span></code></a>(axis)</p></td>
<td><p>Return the index number for the axis with the name “axis”</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.cdf" title="pyspecdata.nddata.cdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cdf</span></code></a>([normalized, max_bins])</p></td>
<td><p>calculate the Cumulative Distribution Function for the data along <cite>axis_name</cite></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.check_axis_coords_errors" title="pyspecdata.nddata.check_axis_coords_errors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_axis_coords_errors</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.chunk" title="pyspecdata.nddata.chunk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chunk</span></code></a>(axisin, *otherargs)</p></td>
<td><p>“Chunking” is defined here to be the opposite of taking a direct product, increasing the number of dimensions by the inverse of the process by which taking a direct product decreases the number of dimensions.  This function chunks axisin into multiple new axes arguments.:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.chunk_auto" title="pyspecdata.nddata.chunk_auto"><code class="xref py py-obj docutils literal notranslate"><span class="pre">chunk_auto</span></code></a>(axis_name, which_field[, dimname])</p></td>
<td><p>assuming that axis “axis_name” is currently labeled with a structured np.array, choose one field (“which_field”) of that structured np.array to generate a new dimension Note that for now, by definition, no error is allowed on the axes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.circshift" title="pyspecdata.nddata.circshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">circshift</span></code></a>(axis, amount)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.contiguous" title="pyspecdata.nddata.contiguous"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contiguous</span></code></a>(lambdafunc[, axis])</p></td>
<td><p>Return contiguous blocks that satisfy the condition given by <cite>lambdafunc</cite></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.contour" title="pyspecdata.nddata.contour"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contour</span></code></a>([labels])</p></td>
<td><p>Contour plot – kwargs are passed to the matplotlib <cite>contour</cite> function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.convolve" title="pyspecdata.nddata.convolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convolve</span></code></a>(axisname, filterwidth[, convfunc])</p></td>
<td><p>Perform a convolution.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.copy" title="pyspecdata.nddata.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([data])</p></td>
<td><p>Return a full copy of this instance.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.copyaxes" title="pyspecdata.nddata.copyaxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyaxes</span></code></a>(other)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.cropped_log" title="pyspecdata.nddata.cropped_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cropped_log</span></code></a>([subplot_axes, magnitude])</p></td>
<td><p>For the purposes of plotting, this generates a copy where I take the log, spanning “magnitude” orders of magnitude This is designed to be called as abs(instance).cropped_log(), so it doesn’t make a copy</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.diff" title="pyspecdata.nddata.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a>(thisaxis[, backwards])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.extend" title="pyspecdata.nddata.extend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extend</span></code></a>(axis, extent[, fill_with, tolerance])</p></td>
<td><p>Extend the (domain of the) dataset and fill with a pre-set value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.extend_for_shear" title="pyspecdata.nddata.extend_for_shear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extend_for_shear</span></code></a>(altered_axis, propto_axis, …)</p></td>
<td><p>this is propto_axis helper function for <cite>.fourier.shear</cite></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.fld" title="pyspecdata.nddata.fld"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fld</span></code></a>(dict_in[, noscalar])</p></td>
<td><p>flatten dictionary – return list</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.fourier_shear" title="pyspecdata.nddata.fourier_shear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fourier_shear</span></code></a>(altered_axis, propto_axis, …)</p></td>
<td><p>the fourier shear method – see .shear() documentation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.fromaxis" title="pyspecdata.nddata.fromaxis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromaxis</span></code></a>(*args, **kwargs)</p></td>
<td><p>Generate an nddata object from one of the axis labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.ft" title="pyspecdata.nddata.ft"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ft</span></code></a>(axes[, tolerance, cosine, verbose])</p></td>
<td><p>This performs a Fourier transform along the axes identified by the string or list of strings <cite>axes</cite>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.ft_clear_startpoints" title="pyspecdata.nddata.ft_clear_startpoints"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ft_clear_startpoints</span></code></a>(axis[, t, f, nearest])</p></td>
<td><p>Clears memory of where the origins in the time and frequency domain are.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.ftshift" title="pyspecdata.nddata.ftshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ftshift</span></code></a>(axis, value)</p></td>
<td><p>FT-based shift.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.get_covariance" title="pyspecdata.nddata.get_covariance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_covariance</span></code></a>()</p></td>
<td><p>this returns the covariance matrix of the data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.get_error" title="pyspecdata.nddata.get_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_error</span></code></a>(*args)</p></td>
<td><p>get a copy of the errors either set_error(‘axisname’,error_for_axis) or set_error(error_for_data)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.get_ft_prop" title="pyspecdata.nddata.get_ft_prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ft_prop</span></code></a>(axis[, propname])</p></td>
<td><p>Gets the FT property given by <cite>propname</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.get_plot_color" title="pyspecdata.nddata.get_plot_color"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_plot_color</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.get_prop" title="pyspecdata.nddata.get_prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_prop</span></code></a>([propname])</p></td>
<td><p>return arbitrary ND-data properties (typically acquisition parameters <em>etc.</em>) by name (<cite>propname</cite>)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.get_units" title="pyspecdata.nddata.get_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_units</span></code></a>(*args)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.getaxis" title="pyspecdata.nddata.getaxis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getaxis</span></code></a>(axisname)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.getaxisshape" title="pyspecdata.nddata.getaxisshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getaxisshape</span></code></a>(axisname)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.gnuplot_save" title="pyspecdata.nddata.gnuplot_save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gnuplot_save</span></code></a>(filename)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.hdf5_write" title="pyspecdata.nddata.hdf5_write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hdf5_write</span></code></a>(h5path[, directory])</p></td>
<td><p>Write the nddata to an HDF5 file.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.histogram" title="pyspecdata.nddata.histogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histogram</span></code></a>(**kwargs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.human_units" title="pyspecdata.nddata.human_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">human_units</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.ift" title="pyspecdata.nddata.ift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ift</span></code></a>(axes[, n, tolerance, verbose])</p></td>
<td><p>This performs an inverse Fourier transform along the axes identified by the string or list of strings <cite>axes</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.inhomog_coords" title="pyspecdata.nddata.inhomog_coords"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inhomog_coords</span></code></a>(direct_dim, indirect_dim[, …])</p></td>
<td><p>Apply the “inhomogeneity transform,” which rotates the data by <span class="math notranslate nohighlight">\(45^{\circ}\)</span>, and then mirrors the portion with <span class="math notranslate nohighlight">\(t_2&lt;0\)</span> in order to transform from a <span class="math notranslate nohighlight">\((t_1,t_2)\)</span> coordinate system to a <span class="math notranslate nohighlight">\((t_{inh},t_{homog})\)</span> coordinate system.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.integrate" title="pyspecdata.nddata.integrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate</span></code></a>(thisaxis[, backwards, cumulative])</p></td>
<td><p>Performs an integration – which is similar to a sum, except that it takes the axis into account, <em>i.e.</em>, it performs: <span class="math notranslate nohighlight">\(\int f(x) dx\)</span> rather than <span class="math notranslate nohighlight">\(\sum_i f(x_i)\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.interp" title="pyspecdata.nddata.interp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interp</span></code></a>(axis, axisvalues[, past_bounds, …])</p></td>
<td><p>interpolate data values given axis values</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.invinterp" title="pyspecdata.nddata.invinterp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invinterp</span></code></a>(axis, values, **kwargs)</p></td>
<td><p>interpolate axis values given data values</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id2" title="pyspecdata.nddata.labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">labels</span></code></a>(*args)</p></td>
<td><p>label the dimensions, given in listofstrings with the axis labels given in listofaxes – listofaxes must be a numpy np.array; you can pass either a dictionary or a axis name (string)/axis label (numpy np.array) pair</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.linear_shear" title="pyspecdata.nddata.linear_shear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_shear</span></code></a>(along_axis, propto_axis, shear_amnt)</p></td>
<td><p>the linear shear – see <cite>self.shear</cite> for documentation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.matchdims" title="pyspecdata.nddata.matchdims"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matchdims</span></code></a>(other)</p></td>
<td><p>add any dimensions to self that are not present in other</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.matrices_3d" title="pyspecdata.nddata.matrices_3d"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrices_3d</span></code></a>([also1d, invert, max_dimsize, …])</p></td>
<td><p>returns X,Y,Z,x_axis,y_axis matrices X,Y,Z, are suitable for a variety of mesh plotting, etc, routines x_axis and y_axis are the x and y axes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.mayavi_surf" title="pyspecdata.nddata.mayavi_surf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mayavi_surf</span></code></a>()</p></td>
<td><p>use the mayavi surf function, assuming that we’ve already loaded mlab during initialization</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.mean" title="pyspecdata.nddata.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(*args, **kwargs)</p></td>
<td><p>Take the mean and (optionally) set the error to the standard deviation</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.mean_all_but" title="pyspecdata.nddata.mean_all_but"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_all_but</span></code></a>(listofdims)</p></td>
<td><p>take the mean over all dimensions not in the list</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.mean_nopop" title="pyspecdata.nddata.mean_nopop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_nopop</span></code></a>(axis)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.mean_weighted" title="pyspecdata.nddata.mean_weighted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_weighted</span></code></a>(axisname)</p></td>
<td><p>perform  the weighted mean along <cite>axisname</cite> (use $sigma$ from $sigma = $self.get_error() do generate $1/sigma$ weights) for now, it clears the error of <cite>self</cite>, though it would be easy to calculate the new error, since everything is linear</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.meshplot" title="pyspecdata.nddata.meshplot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meshplot</span></code></a>([stride, alpha, onlycolor, light, …])</p></td>
<td><p>takes both rotation and light as elevation, azimuth only use the light kwarg to generate a black and white shading display</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.mkd" title="pyspecdata.nddata.mkd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mkd</span></code></a>(*arg, **kwargs)</p></td>
<td><p>make dictionary format</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.multimin" title="pyspecdata.nddata.multimin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multimin</span></code></a>(minfunc, axisname, filterwidth, …)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.name" title="pyspecdata.nddata.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a>(*arg)</p></td>
<td><p>args: .name(newname) –&gt; Name the object (for storage, etc) .name() –&gt; Return the name</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.normalize" title="pyspecdata.nddata.normalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize</span></code></a>(axis[, first_figure])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.oldtimey" title="pyspecdata.nddata.oldtimey"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oldtimey</span></code></a>([alpha, ax, linewidth, …])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.plot_labels" title="pyspecdata.nddata.plot_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_labels</span></code></a>(labels[, fmt])</p></td>
<td><p>this only works for one axis now</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.polyfit" title="pyspecdata.nddata.polyfit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polyfit</span></code></a>(axis[, order, force_y_intercept])</p></td>
<td><p>polynomial fitting routine – return the coefficients and the fit ..note:     later, should probably branch this off as a new type of fit class</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.popdim" title="pyspecdata.nddata.popdim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">popdim</span></code></a>(dimname)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.random_mask" title="pyspecdata.nddata.random_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_mask</span></code></a>(axisname[, threshold, inversion])</p></td>
<td><p>generate a random mask with about ‘threshold’ of the points thrown out</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.real" title="pyspecdata.nddata.real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">real</span></code></a></p></td>
<td><p>Return the real component of the data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.register_axis" title="pyspecdata.nddata.register_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_axis</span></code></a>(arg[, nearest])</p></td>
<td><p>Interpolate the data so that the given axes are in register with a set of specified values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.rename" title="pyspecdata.nddata.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>(previous, new)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.reorder" title="pyspecdata.nddata.reorder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder</span></code></a>(*axes, **kwargs)</p></td>
<td><p>Reorder the dimensions the first arguments are a list of dimensions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.replicate_units" title="pyspecdata.nddata.replicate_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replicate_units</span></code></a>(other)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.repwlabels" title="pyspecdata.nddata.repwlabels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repwlabels</span></code></a>(axis)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.retaxis" title="pyspecdata.nddata.retaxis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">retaxis</span></code></a>(axisname)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.run" title="pyspecdata.nddata.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>(*args)</p></td>
<td><p>run a standard numpy function on the nddata:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.run_avg" title="pyspecdata.nddata.run_avg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_avg</span></code></a>(thisaxisname[, decimation, centered])</p></td>
<td><p>a simple running average</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.run_nopop" title="pyspecdata.nddata.run_nopop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_nopop</span></code></a>(func, axis)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.runcopy" title="pyspecdata.nddata.runcopy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runcopy</span></code></a>(*args)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.set_error" title="pyspecdata.nddata.set_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_error</span></code></a>(*args)</p></td>
<td><p>set the errors: either</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.set_ft_prop" title="pyspecdata.nddata.set_ft_prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_ft_prop</span></code></a>(axis[, propname, value])</p></td>
<td><p>Sets the FT property given by <cite>propname</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.set_plot_color" title="pyspecdata.nddata.set_plot_color"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_plot_color</span></code></a>(thiscolor)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.set_prop" title="pyspecdata.nddata.set_prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_prop</span></code></a>(*args)</p></td>
<td><p>set a ‘property’ of the nddata This is where you can put all unstructured information (e.g.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.set_units" title="pyspecdata.nddata.set_units"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_units</span></code></a>(*args)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.setaxis" title="pyspecdata.nddata.setaxis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setaxis</span></code></a>(*args)</p></td>
<td><p>set or alter the value of the coordinate axis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.shear" title="pyspecdata.nddata.shear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shear</span></code></a>(along_axis, propto_axis, shear_amnt[, …])</p></td>
<td><p>Shear the data <span class="math notranslate nohighlight">\(s\)</span>:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.smoosh" title="pyspecdata.nddata.smoosh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">smoosh</span></code></a>(dimstocollapse[, dimname, noaxis])</p></td>
<td><p>Collapse (smoosh) multiple dimensions into one dimension.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.sort" title="pyspecdata.nddata.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a>(axisname[, reverse])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.sort_and_xy" title="pyspecdata.nddata.sort_and_xy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_and_xy</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pyspecdata.nddata.squeeze" title="pyspecdata.nddata.squeeze"><code class="xref py py-obj docutils literal notranslate"><span class="pre">squeeze</span></code></a>([return_dropped])</p></td>
<td><p>squeeze singleton dimensions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.sum" title="pyspecdata.nddata.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(axes)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.sum_nopop" title="pyspecdata.nddata.sum_nopop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum_nopop</span></code></a>(axes)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.unitify_axis" title="pyspecdata.nddata.unitify_axis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unitify_axis</span></code></a>(axis_name[, is_axis])</p></td>
<td><p>this just generates an axis label with appropriate units</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.units_texsafe" title="pyspecdata.nddata.units_texsafe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">units_texsafe</span></code></a>(*args)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pyspecdata.nddata.unset_prop" title="pyspecdata.nddata.unset_prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unset_prop</span></code></a>(arg)</p></td>
<td><p>remove a ‘property’</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.waterfall" title="pyspecdata.nddata.waterfall"><code class="xref py py-obj docutils literal notranslate"><span class="pre">waterfall</span></code></a>([alpha, ax, rotation, color, …])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata.want_to_prospa_decim_correct" title="pyspecdata.nddata.want_to_prospa_decim_correct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">want_to_prospa_decim_correct</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py class">
<dt id="id0">
<em class="property">class </em><code class="sig-prename descclassname">pyspecdata.</code><code class="sig-name descname">nddata</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the detailed API reference.
For an introduction on how to use ND-Data, see the <a class="reference internal" href="nddata.html#nddata-summary-label"><span class="std std-ref">Main ND-Data Documentation</span></a>.</p>
<dl class="py method">
<dt id="pyspecdata.nddata.C">
<em class="property">property </em><code class="sig-name descname">C</code><a class="headerlink" href="#pyspecdata.nddata.C" title="Permalink to this definition">¶</a></dt>
<dd><p>shortcut for copy</p>
<p>btw, what we are doing is analogous to a ruby function with
functioname!() modify result, and we can use the “out” keyword in
numpy.</p>
<dl>
<dt>..todo::</dt><dd><p>(new idea)
This should just set a flag that says “Do not allow this data to be substituted in place,”
so that if something goes to edit the data in place,
it instead first makes a copy.</p>
<p>also here, see <a class="reference external" href="https://docs.python.org/2/library/copy.html">Definition of shallow and deep copy</a></p>
<p>(older idea)
We should offer “N”, which generates something like a copy,
but which is sets the equivalent of “nopop”.
For example, currently, you need to do something like
<code class="docutils literal notranslate"><span class="pre">d.C.argmax('t2')</span></code>,
which is very inefficient, since it copies the whole np.array.
So, instead, we should do
<code class="docutils literal notranslate"><span class="pre">d.N.argmax('t2')</span></code>, which tells argmax and all other
functions not to overwrite “self” but to return a new object.
This would cause things like “run_nopop” to become obsolete.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.add_noise">
<code class="sig-name descname">add_noise</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">intensity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.add_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Gaussian (box-muller) noise to the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>intensity</strong> (<em>double OR function</em>) – If a double, gives the standard deviation of the noise.
If a function, used to calculate the standard deviation of the noise from the data:
<em>e.g.</em> <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">max(abs(x))/10.</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.aligndata">
<code class="sig-name descname">aligndata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.aligndata" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a fundamental method used by all of the arithmetic operations.
It uses the dimension labels of <cite>self</cite> (the current instance) and <cite>arg</cite>
(an nddata passed to this method) to generate two corresponding output
nddatas that I refer to here, respectively, as <cite>A</cite> and <cite>B</cite>.  <cite>A</cite> and
<cite>B</cite> have dimensions that are “aligned” – that is, they are identical
except for singleton dimensions (note that numpy automatically tiles
singleton dimensions).  Regardless of how the dimensions of <cite>self.data</cite>
and <cite>arg.data</cite> (the underlying numpy data) were ordered, <cite>A.data</cite> and
<cite>B.data</cite> are now ordered identically, where dimensions with the same
label (<cite>.dimlabel</cite>) correspond to the same numpy index.  This allows
you do do math.</p>
<p>Note that, currently, both <cite>A</cite> and <cite>B</cite> are given a full set of axis
labels, even for singleton dimensions.  This is because we’re assuming
you’re going to do math with them, and that the singleton dimensions
will be expanded.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>arg</strong> (<a class="reference internal" href="generated/pyspecdata.core.nddata.html#pyspecdata.core.nddata" title="pyspecdata.core.nddata"><em>nddata</em></a><em> or </em><em>np.ndarray</em>) – The nddata that you want to align to <cite>self</cite>.
If arg is an np.ndarray, it will try to match dimensions to self based
on the length of the dimension.
<strong>Note:</strong> currently there is an issue where this will only really
work for 1D data, since it first makes an nddata instance based on
arg, which apparently collapses multi-D data to 1D data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>A</strong> (<em>nddata</em>) – realigned version of <cite>self</cite></p></li>
<li><p><strong>B</strong> (<em>nddata</em>) – realigned version of <cite>arg</cite> (the argument)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.along">
<code class="sig-name descname">along</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dimname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.along" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the dimension for the next matrix
multiplication (represents the rows/columns).</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.angle">
<em class="property">property </em><code class="sig-name descname">angle</code><a class="headerlink" href="#pyspecdata.nddata.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the angle component of the data</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.argmax">
<code class="sig-name descname">argmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>find the max along a particular axis, and get rid of that axis, replacing it with the index number of the max value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>raw_index</strong> (<em>bool</em>) – return the raw (np.ndarray) numerical index, rather than the corresponding axis value
Note that the result returned is still, however, an nddata (rather than numpy np.ndarray) object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.argmin">
<code class="sig-name descname">argmin</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">axes</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>If <cite>np.argmin(‘axisname’)</cite> find the min along a particular axis, and get rid of that
axis, replacing it with the index number of the max value.
If <cite>np.argmin()</cite>: return a dictionary giving the coordinates of the overall minimum point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>raw_index</strong> (<em>bool</em>) – Return the raw (np.ndarray) numerical index, rather than the corresponding axis value.
Note that the result returned is still, however, an nddata (rather than numpy np.ndarray) object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.axis">
<code class="sig-name descname">axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axisname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.axis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a 1-D axis for further manipulation</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.axlen">
<code class="sig-name descname">axlen</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.axlen" title="Permalink to this definition">¶</a></dt>
<dd><p>return the size (length) of an axis, by name</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> (<em>str</em>) – name of the axis whos length you are interested in</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.axn">
<code class="sig-name descname">axn</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.axn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index number for the axis with the name “axis”</p>
<p>This is used by many other methods.
As a simple example,
self.:func:<cite>axlen`(axis) (the axis length) returns
``np.shape(self.data)[self.axn(axis)]`</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>axis</strong> (<em>str</em>) – name of the axis</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.cdf">
<code class="sig-name descname">cdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">normalized</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">max_bins</span><span class="o">=</span><span class="default_value">500</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.cdf" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the Cumulative Distribution Function for the data along <cite>axis_name</cite></p>
<p>only for 1D data right now</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>A new nddata object with an axis labeled <cite>values</cite>, and data corresponding to the CDF.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.chunk">
<code class="sig-name descname">chunk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axisin</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">otherargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.chunk" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>“Chunking” is defined here to be the opposite of taking a direct product, increasing the number of dimensions by the inverse of the process by which taking a direct product decreases the number of dimensions.  This function chunks axisin into multiple new axes arguments.:</dt><dd><p>axesout – gives the names of the output axes
shapesout – optional – if not given, it assumes equal length – if given, one of the values can be -1, which is assumed length</p>
</dd>
</dl>
<p>When there are axes, it assumes that the axes of the new dimensions
are nested – <em>e.g.</em>, it will chunk a dimension with axis:
[1,2,3,4,5,6,7,8,9,10]
into dimensions with axes:
[0,1,2,3,4], [1,6]</p>
<dl class="simple">
<dt>..todo::</dt><dd><p>Deal with this efficiently when we move to new-style axes</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.chunk_auto">
<code class="sig-name descname">chunk_auto</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis_name</span></em>, <em class="sig-param"><span class="n">which_field</span></em>, <em class="sig-param"><span class="n">dimname</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.chunk_auto" title="Permalink to this definition">¶</a></dt>
<dd><p>assuming that axis “axis_name” is currently labeled with a structured np.array, choose one field (“which_field”) of that structured np.array to generate a new dimension
Note that for now, by definition, no error is allowed on the axes.
However, once I upgrade to using structured arrays to handle axis and data errors, I will want to deal with that appropriately here.</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.contiguous">
<code class="sig-name descname">contiguous</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lambdafunc</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Return contiguous blocks that satisfy the condition given by <cite>lambdafunc</cite></p>
<p>this function returns the start and stop positions along the
axis for the contiguous blocks for which lambdafunc returns
true
<strong>Currently only supported for 1D data</strong></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>adapted from stackexchange post <a class="reference external" href="http://stackoverflow.com/questions/4494404/find-large-number-of-consecutive-values-fulfilling-condition-in-a-numpy-array">http://stackoverflow.com/questions/4494404/find-large-number-of-consecutive-values-fulfilling-condition-in-a-numpy-array</a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lambdafunc</strong> (<em>types.FunctionType</em>) – If only one argument (lambdafunc) is given,
then lambdafunc is
a function that accepts a copy of the current nddata object
(<cite>self</cite>) as the argument.
If two arguments are given,
the second is <cite>axis</cite>, and lambdafunc has two arguments,
<cite>self</cite> and the value of <cite>axis</cite>.</p></li>
<li><p><strong>axis</strong> (<em>{None</em><em>,</em><em>str}</em>) – the name of the axis along which you want to find contiguous
blocks</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>retval</strong> – An <span class="math notranslate nohighlight">\(N\times 2\)</span> matrix, where the <span class="math notranslate nohighlight">\(N\)</span> rows correspond to pairs of axis
label that give ranges over which <cite>lambdafunc</cite> evaluates to <cite>True</cite>.
These are ordered according to descending range width.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sum_for_contiguous</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">forplot</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="s1">&#39;t1&#39;</span><span class="p">)</span>
<span class="n">fl</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="s2">&quot;test contiguous&quot;</span><span class="p">)</span>
<span class="n">forplot</span> <span class="o">=</span> <span class="n">sum_for_contiguous</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">set_error</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="n">fl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">forplot</span><span class="p">,</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span><span class="n">linewidth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;this is what the max looks like&quot;</span><span class="p">,</span><span class="mf">0.5</span><span class="o">*</span><span class="n">sum_for_contiguous</span><span class="o">.</span><span class="n">set_error</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">runcopy</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span><span class="s1">&#39;t2&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sum_for_contiguous</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">sum_for_contiguous</span><span class="o">.</span><span class="n">runcopy</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span><span class="s1">&#39;t2&#39;</span><span class="p">))</span>
<span class="n">retval</span> <span class="o">=</span> <span class="n">sum_for_contiguous</span><span class="o">.</span><span class="n">contiguous</span><span class="p">(</span><span class="n">quarter_of_max</span><span class="p">,</span><span class="s1">&#39;t2&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;contiguous range / 1e6:&quot;</span><span class="p">,</span><span class="n">retval</span><span class="o">/</span><span class="mf">1e6</span><span class="p">)</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">retval</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">retval</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>
    <span class="n">fl</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">forplot</span><span class="p">[</span><span class="s1">&#39;t2&#39;</span><span class="p">:(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.contour">
<code class="sig-name descname">contour</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Contour plot – kwargs are passed to the matplotlib
<cite>contour</cite> function.</p>
<p>See docstring of <cite>figlist_var.image()</cite> for an example</p>
<dl class="py attribute">
<dt id="pyspecdata.nddata.labels">
<code class="sig-name descname">labels</code><a class="headerlink" href="#pyspecdata.nddata.labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not the levels should be labeled.
Defaults to True</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.convolve">
<code class="sig-name descname">convolve</code><span class="sig-paren">(</span><em class="sig-param">axisname</em>, <em class="sig-param">filterwidth</em>, <em class="sig-param">convfunc=&lt;function &lt;lambda&gt;&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a convolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axisname</strong> (<em>str</em>) – apply the convolution along <cite>axisname</cite></p></li>
<li><p><strong>filterwidth</strong> (<em>double</em>) – width of the convolution function.</p></li>
<li><p><strong>convfunc</strong> (<em>function</em>) – A function that takes two arguments – the first are the axis coordinates and the second is <cite>filterwidth</cite>.
Default is a normalized Gaussian of width (<span class="math notranslate nohighlight">\(\sigma\)</span>)
<cite>filterwidth</cite>
<span class="math notranslate nohighlight">\(\frac{1}{2 \sigma^2}\exp\left( - \frac{x^2}{2 \sigma^2} \right)\)</span>
For example if you want a complex Lorentzian with <cite>filterwidth</cite> controlled by the rate <span class="math notranslate nohighlight">\(R\)</span>,
<em>i.e.</em>
<span class="math notranslate nohighlight">\(\frac{-1}{-i 2 \pi f - R}\)</span>
then <code class="docutils literal notranslate"><span class="pre">convfunc</span> <span class="pre">=</span> <span class="pre">lambda</span> <span class="pre">f,R:</span> <span class="pre">-1./(-1j*2*pi*f-R)</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a full copy of this instance.</p>
<p>Because methods typically change the data in place, you might want to
use this frequently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>boolean</em>) – <p>Default to True.
False doesn’t copy the data – this is for internal use,
<em>e.g.</em> when you want to copy all the metadata and perform a
calculation on the data.</p>
<p>The code for this also provides the definitive list of the
nddata metadata.</p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.copy_props">
<code class="sig-name descname">copy_props</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.copy_props" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy all properties (see <a class="reference internal" href="#pyspecdata.nddata.get_prop" title="pyspecdata.nddata.get_prop"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_prop()</span></code></a>) from another nddata
object – note that these include properties pertaining the the FT
status of various dimensions.</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.cropped_log">
<code class="sig-name descname">cropped_log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">subplot_axes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">magnitude</span><span class="o">=</span><span class="default_value">4</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.cropped_log" title="Permalink to this definition">¶</a></dt>
<dd><p>For the purposes of plotting, this generates a copy where I take the log, spanning “magnitude” orders of magnitude
This is designed to be called as abs(instance).cropped_log(), so it doesn’t make a copy</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.dot">
<code class="sig-name descname">dot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor dot of self with arg – dot all matching dimension labels.  This can be used to do matrix multiplication, but note that the order of doesn’t matter, since the dimensions that are contracted are determined by matching the dimension names, not the order of the dimension.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">nddata</span><span class="p">(</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">nddata</span><span class="p">(</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">nddata</span><span class="p">(</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">27</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">nddata</span><span class="p">(</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">nddata</span><span class="p">(</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">27</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">nddata</span><span class="p">(</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">9</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;d&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">a</span><span class="o">.</span><span class="n">C</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">b</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.extend">
<code class="sig-name descname">extend</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">extent</span></em>, <em class="sig-param"><span class="n">fill_with</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">tolerance</span><span class="o">=</span><span class="default_value">1e-05</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.extend" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend the (domain of the) dataset and fill with a pre-set value.</p>
<p>The coordinates associated with
<cite>axis</cite> must be uniformly ascending with spacing <span class="math notranslate nohighlight">\(dx\)</span>.
The function will extend <cite>self</cite>
by adding a point every <span class="math notranslate nohighlight">\(dx\)</span> until the axis
includes the point <cite>extent</cite>.  Fill the newly created datapoints with <cite>fill_with</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (<em>str</em>) – name of the axis to extend</p></li>
<li><p><strong>extent</strong> (<em>double</em>) – <p>Extend the axis coordinates of <cite>axis</cite> out to this value.</p>
<p>The value of <cite>extent</cite> must be less the smallest (most negative)
axis coordinate or greater than the largest (most positive)
axis coordinate.</p>
</p></li>
<li><p><strong>fill_with</strong> (<em>double</em>) – fill the new data points with this value (defaults to 0)</p></li>
<li><p><strong>tolerance</strong> (<em>double</em>) – when checking for ascending axis labels, etc.,
values/differences must match to within tolerance
(assumed to represent the actual precision, given
various errors, etc.)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.extend_for_shear">
<code class="sig-name descname">extend_for_shear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">altered_axis</span></em>, <em class="sig-param"><span class="n">propto_axis</span></em>, <em class="sig-param"><span class="n">skew_amount</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.extend_for_shear" title="Permalink to this definition">¶</a></dt>
<dd><p>this is propto_axis helper function for <cite>.fourier.shear</cite></p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.fld">
<code class="sig-name descname">fld</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dict_in</span></em>, <em class="sig-param"><span class="n">noscalar</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.fld" title="Permalink to this definition">¶</a></dt>
<dd><p>flatten dictionary – return list</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.fourier_shear">
<code class="sig-name descname">fourier_shear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">altered_axis</span></em>, <em class="sig-param"><span class="n">propto_axis</span></em>, <em class="sig-param"><span class="n">by_amount</span></em>, <em class="sig-param"><span class="n">zero_fill</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">start_in_conj</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.fourier_shear" title="Permalink to this definition">¶</a></dt>
<dd><p>the fourier shear method – see .shear() documentation</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.fromaxis">
<code class="sig-name descname">fromaxis</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.fromaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an nddata object from one of the axis labels.</p>
<p>Can be used in one of several ways:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self.fromaxis('axisname')</span></code>: Returns an nddata where <cite>retval.data</cite> consists of the given axis values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.fromaxis('axisname',inputfunc)</span></code>: use <cite>axisname</cite> as the input for <cite>inputfunc</cite>, and load the result into <cite>retval.data</cite></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.fromaxis(inputsymbolic)</span></code>: Evaluate <cite>inputsymbolic</cite> and load the result into <cite>retval.data</cite></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axisname</strong> (<em>str | list</em>) – The axis (or list of axes) to that is used as the argument of <cite>inputfunc</cite> or the function represented by <cite>inputsymbolic</cite>.
If this is the only argument, it cannot be a list.</p></li>
<li><p><strong>inputsymbolic</strong> (<em>sympy.Expr</em>) – A sympy expression whose only symbols are the names of axes.
It is preferred, though not required, that this is passed
without an <cite>axisname</cite> argument – the axis names are then
inferred from the symbolic expression.</p></li>
<li><p><strong>inputfunc</strong> (<em>function</em>) – A function (typically a lambda function) that taxes the values of the axis given by <cite>axisname</cite> as input.</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em>) – Defaults to <cite>False</cite>. If set to <cite>True</cite>, it overwrites <cite>self</cite> with <cite>retval</cite>.</p></li>
<li><p><strong>as_array</strong> (<em>bool</em>) – Defaults to <cite>False</cite>. If set to <cite>True</cite>, <cite>retval</cite> is a properly dimensioned numpy ndarray rather than an nddata.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>retval</strong> – An expression calculated from the axis(es) given by <cite>axisname</cite> or inferred from <cite>inputsymbolic</cite>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nddata | ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.ft">
<code class="sig-name descname">ft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axes</span></em>, <em class="sig-param"><span class="n">tolerance</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">cosine</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ft" title="Permalink to this definition">¶</a></dt>
<dd><p>This performs a Fourier transform along the axes identified by the string or list of strings <cite>axes</cite>.</p>
<dl class="simple">
<dt>It adjusts normalization and units so that the result conforms to</dt><dd><p><span class="math notranslate nohighlight">\(\tilde{s}(f)=\int_{x_{min}}^{x_{max}} s(t) e^{-i 2 \pi f t} dt\)</span></p>
</dd>
</dl>
<p>Note that, as noted in the <a class="reference internal" href="auto_api/pyspecdata.fourier.html#pyspecdata.fourier.ift.ift" title="pyspecdata.fourier.ift.ift"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ift()</span></code></a> documentation,
the inverse transform doesn’t correspond to the equivalent
expression for the IFT.</p>
<p><strong>pre-FT</strong>, we use the axis to cyclically permute <span class="math notranslate nohighlight">\(t=0\)</span> to the first index</p>
<p><strong>post-FT</strong>, we assume that the data has previously been IFT’d
If this is the case, passing <code class="docutils literal notranslate"><span class="pre">shift=True</span></code> will cause an error
If this is not the case, passing <code class="docutils literal notranslate"><span class="pre">shift=True</span></code> generates a standard fftshift
<code class="docutils literal notranslate"><span class="pre">shift=None</span></code> will choose True, if and only if this is not the case</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pad</strong> (<em>int</em><em> or </em><em>boolean</em>) – <cite>pad</cite> specifies a zero-filling.  If it’s a number, then it gives
the length of the zero-filled dimension.  If it is just <cite>True</cite>,
then the size of the dimension is determined by rounding the
dimension size up to the nearest integral power of 2.</p></li>
<li><p><strong>automix</strong> (<em>double</em>) – <cite>automix</cite> can be set to the approximate frequency value.  This is
useful for the specific case where the data has been captured on a
sampling scope, and it’s severely aliased over.</p></li>
<li><p><strong>cosine</strong> (<em>boolean</em>) – yields a sum of the fft and ifft, for a cosine transform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.ft_clear_startpoints">
<code class="sig-name descname">ft_clear_startpoints</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">f</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nearest</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ft_clear_startpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears memory of where the origins in the time and frequency domain are.
This is useful, <em>e.g.</em> when you want to ift and center about time=0.
By setting shift=True you can also manually set the points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>float</em><em>, </em><em>'current'</em><em>, </em><em>'reset'</em><em>, or </em><em>None</em>) – keyword arguments <cite>t</cite> and <cite>f</cite> can be set by (1) manually setting
the start point (2) using the string ‘current’ to leave the
current setting a lone (3) ‘reset’, which clears the startpoint
and (4) None, which will be changed to ‘current’ when the other is set to a number or ‘rest’ if both are set to None.</p></li>
<li><p><strong>t</strong> – see <cite>t</cite></p></li>
<li><p><strong>nearest</strong> (<em>bool</em>) – <p>Shifting the startpoint can only be done
by an integral number of datapoints
(<em>i.e.</em> an integral number of dwell
times, dt, in the time domain or
integral number of df in the frequency
domain).
While it is possible to shift by a
non-integral number of datapoints,
this is done by applying a
phase-dependent shift in the inverse
domain.
Applying such a axis-dependent shift
can have vary unexpected effects if the
data in the inverse domain is aliased,
and is therefore heavily discouraged.
(For example, consider what happens if
we attempt to apply a
frequency-dependent phase shift to data
where a peak at 110 Hz is aliased and
appears at the 10 Hz position.)</p>
<p>Setting <cite>nearest</cite> to <strong>True</strong>
will choose a startpoint at the closest
integral datapoint to what you have
specified.</p>
<p>Setting <cite>nearest</cite> to <strong>False</strong>
will explicitly override the safeties –
essentially telling the code that you
know the data is not aliased in the
inverse domain and/or are willing to
deal with the consequences.</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.ft_state_to_str">
<code class="sig-name descname">ft_state_to_str</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">axes</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ft_state_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string that lists the FT domain for the given axes.</p>
<p><span class="math notranslate nohighlight">\(u\)</span> refers to the original domain (typically time) and <span class="math notranslate nohighlight">\(v\)</span> refers to the FT’d domain (typically frequency)
If no axes are passed as arguments, it does this for all axes.</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.ftshift">
<code class="sig-name descname">ftshift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ftshift" title="Permalink to this definition">¶</a></dt>
<dd><p>FT-based shift.  Currently only works in time domain.</p>
<p>This was previously made obsolete, but is now a demo of how to use the ft properties.
It is not the most efficient way to do this.</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.get_covariance">
<code class="sig-name descname">get_covariance</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.get_covariance" title="Permalink to this definition">¶</a></dt>
<dd><p>this returns the covariance matrix of the data</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.get_error">
<code class="sig-name descname">get_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.get_error" title="Permalink to this definition">¶</a></dt>
<dd><p>get a copy of the errors
either set_error(‘axisname’,error_for_axis) or set_error(error_for_data)</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.get_ft_prop">
<code class="sig-name descname">get_ft_prop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">propname</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.get_ft_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the FT property given by <cite>propname</cite>.  For both setting and getting, <cite>None</cite> is equivalent to an unset value if no <cite>propname</cite> is given, this just sets the <cite>FT</cite> property, which tells if a dimension is frequency or time domain</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.get_prop">
<code class="sig-name descname">get_prop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">propname</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.get_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>return arbitrary ND-data properties (typically acquisition parameters <em>etc.</em>) by name (<cite>propname</cite>)</p>
<p>In order to allow ND-data to store acquisition parameters and other info that accompanies the data,
but might not be structured in a gridded format, nddata instances
always have a <cite>other_info</cite> dictionary attribute,
which stores these properties by name.</p>
<p>If the property doesn’t exist, this returns <cite>None</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>propname</strong> (<em>str</em>) – <p>Name of the property that you’re want returned.
If this is left out or set to “None” (not given), the names of the available
properties are returned.
If no exact match is found, and propname contains a . or * or [, it’s
assumed to be a regular expression.
If several such matches are found, the error message is informative.</p>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>have it recursively search dictionaries (e.g. bruker acq)</p>
</div>
</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>The value of the property (can by any type) or <cite>None</cite> if the property doesn’t exist.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.hdf5_write">
<code class="sig-name descname">hdf5_write</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">h5path</span></em>, <em class="sig-param"><span class="n">directory</span><span class="o">=</span><span class="default_value">'.'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.hdf5_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the nddata to an HDF5 file.</p>
<p><cite>h5path</cite> is the name of the file followed by the node path where
you want to put it – it does <strong>not</strong> include the directory where
the file lives.
The directory can be passed to the <cite>directory</cite> argument.</p>
<p>You can use either <a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.find_file" title="pyspecdata.find_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">find_file()</span></code></a> or
<a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.nddata_hdf5" title="pyspecdata.nddata_hdf5"><code class="xref py py-func docutils literal notranslate"><span class="pre">nddata_hdf5()</span></code></a> to read the data, as shown below.
When reading this, please note that HDF5 files store <em>multiple</em> datasets,
and each is named (here, the name is <cite>test_data</cite>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyspecdata</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">init_logging</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">nddata</span><span class="p">(</span><span class="n">r_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="n">j</span><span class="p">],</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s1">&#39;test_data&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">a</span><span class="o">.</span><span class="n">hdf5_write</span><span class="p">(</span><span class="s1">&#39;example.h5&#39;</span><span class="p">,</span><span class="n">getDATADIR</span><span class="p">(</span><span class="n">exp_type</span><span class="o">=</span><span class="s1">&#39;Sam&#39;</span><span class="p">))</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;file already exists, not creating again -- delete the file or node if wanted&quot;</span><span class="p">)</span>
<span class="c1"># read the file by the &quot;raw method&quot;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">nddata_hdf5</span><span class="p">(</span><span class="s1">&#39;example.h5/test_data&#39;</span><span class="p">,</span>
        <span class="n">getDATADIR</span><span class="p">(</span><span class="n">exp_type</span><span class="o">=</span><span class="s1">&#39;Sam&#39;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;found data:&quot;</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="c1"># or use the find file method</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">find_file</span><span class="p">(</span><span class="s1">&#39;example.h5&#39;</span><span class="p">,</span> <span class="n">exp_type</span><span class="o">=</span><span class="s1">&#39;Sam&#39;</span><span class="p">,</span>
        <span class="n">expno</span><span class="o">=</span><span class="s1">&#39;test_data&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;found data:&quot;</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h5path</strong> (<em>str</em>) – The name of the file followed by the node path where
you want to put it – it does <strong>not</strong> include the directory where
the file lives.
(Because HDF5 files contain an internal directory-like group
structure.)</p></li>
<li><p><strong>directory</strong> (<em>str</em>) – the directory where the HDF5 file lives.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.ift">
<code class="sig-name descname">ift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axes</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tolerance</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.ift" title="Permalink to this definition">¶</a></dt>
<dd><p>This performs an inverse Fourier transform along the axes identified by the string or list of strings <cite>axes</cite>.</p>
<dl class="simple">
<dt>It adjusts normalization and units so that the result conforms to</dt><dd><p><span class="math notranslate nohighlight">\(s(t)=t_{dw} \int_{x_{min}}^{x_{max}} \tilde{s}(f) e^{i 2 \pi f t} df\)</span></p>
</dd>
</dl>
<p>Where <span class="math notranslate nohighlight">\(t_{dw}=\frac{1}{\Delta f}\)</span>, is the dwell time (with <span class="math notranslate nohighlight">\(\Delta f\)</span> the spectral width).</p>
<p><em>Why do we do this?</em> Note that while the analytical integral this corresponds to is normalized, performing
<a class="reference internal" href="#pyspecdata.nddata.ft" title="pyspecdata.nddata.ft"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ft()</span></code></a> followed by <a class="reference internal" href="#pyspecdata.nddata.ift" title="pyspecdata.nddata.ift"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ift()</span></code></a> on a discrete sequence is NOT completely invertible
(due to integration of the implied comb function??),
and would require division by a factor of <span class="math notranslate nohighlight">\(\Delta f\)</span> (the spectral width) in order
to retrieve the original function</p>
<p><strong>pre-IFT</strong>, we use the axis to cyclically permute <span class="math notranslate nohighlight">\(f=0\)</span> to the first index</p>
<p><strong>post-IFT</strong>, we assume that the data has previously been FT’d
If this is the case, passing <code class="docutils literal notranslate"><span class="pre">shift=True</span></code> will cause an error
If this is not the case, passing <code class="docutils literal notranslate"><span class="pre">shift=True</span></code> generates a standard ifftshift
<code class="docutils literal notranslate"><span class="pre">shift=None</span></code> will choose True, if and only if this is not the case</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pad</strong> (<em>int</em><em> or </em><em>boolean</em>) – <p><cite>pad</cite> specifies a zero-filling.  If it’s a number, then it gives
the length of the zero-filled dimension.  If it is just <cite>True</cite>,
then the size of the dimension is determined by rounding the
dimension size up to the nearest integral power of 2.   It uses the
<cite>start_time</cite> ft property to determine the start of the axis.  To
do this, it assumes that it is a stationary signal
(convolved with infinite comb function).
The value of <cite>start_time</cite> can differ from by a non-integral multiple of
<span class="math notranslate nohighlight">\(\Delta t\)</span>, though the routine will check whether or not it is safe to
do this.</p>
<dl class="simple">
<dt>..note ::</dt><dd><p>In the code, this is controlled by <cite>p2_post</cite> (the integral
<span class="math notranslate nohighlight">\(\Delta t\)</span> and <cite>p2_post_discrepancy</cite> – the non-integral.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.imag">
<em class="property">property </em><code class="sig-name descname">imag</code><a class="headerlink" href="#pyspecdata.nddata.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imag component of the data</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.indices">
<code class="sig-name descname">indices</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis_name</span></em>, <em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string of indeces that most closely match the axis labels corresponding to values. Filter them to make sure they are unique.</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.inhomog_coords">
<code class="sig-name descname">inhomog_coords</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">direct_dim</span></em>, <em class="sig-param"><span class="n">indirect_dim</span></em>, <em class="sig-param"><span class="n">tolerance</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">plot_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">debug_kwargs</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.inhomog_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the “inhomogeneity transform,” which rotates the data by <span class="math notranslate nohighlight">\(45^{\circ}\)</span>, and then mirrors the portion with <span class="math notranslate nohighlight">\(t_2&lt;0\)</span> in order to transform from a <span class="math notranslate nohighlight">\((t_1,t_2)\)</span> coordinate system to a <span class="math notranslate nohighlight">\((t_{inh},t_{homog})\)</span> coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>direct_dim</strong> (<em>str</em>) – Label of the direct dimension (typically <span class="math notranslate nohighlight">\(t_2\)</span>)</p></li>
<li><p><strong>indirect_dim</strong> (<em>str</em>) – Label of the indirect dimension (typically <span class="math notranslate nohighlight">\(t_1\)</span>)</p></li>
<li><p><strong>method</strong> (<em>'linear'</em><em>, </em><em>'fourier'</em>) – The interpolation method used to rotate the data and to mirror the data.
<strong>Note</strong> currently, both use a fourier-based mirroring method.</p></li>
<li><p><strong>plot_name</strong> (<em>str</em>) – the base name for the plots that are generated</p></li>
<li><p><strong>fl</strong> (<em>figlist_var</em>) – </p></li>
<li><p><strong>debug_kwargs</strong> (<em>dict</em>) – <p>with keys:</p>
<dl class="field-list simple">
<dt class="field-odd"><cite>correct_overlap</cite></dt>
<dd class="field-odd"><p>if False, doesn’t correct for the overlap error that occurs during mirroring</p>
</dd>
</dl>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.integrate">
<code class="sig-name descname">integrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">thisaxis</span></em>, <em class="sig-param"><span class="n">backwards</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">cumulative</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs an integration – which is similar to a sum, except that it takes the axis into account, <em>i.e.</em>, it performs:
<span class="math notranslate nohighlight">\(\int f(x) dx\)</span>
rather than
<span class="math notranslate nohighlight">\(\sum_i f(x_i)\)</span></p>
<p>Gaussian quadrature, etc, is planned for a future version.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>thisaxis</strong> – The dimension that you want to integrate along</p></li>
<li><p><strong>cumulative</strong> (<em>boolean</em><em> (</em><em>default False</em><em>)</em>) – Perform a cumulative integral (analogous to a cumulative sum)
– <em>e.g.</em> for ESR.</p></li>
<li><p><strong>backwards</strong> (<em>boolean</em><em> (</em><em>default False</em><em>)</em>) – for cumulative integration – perform the integration backwards</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.interp">
<code class="sig-name descname">interp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">axisvalues</span></em>, <em class="sig-param"><span class="n">past_bounds</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_func</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.interp" title="Permalink to this definition">¶</a></dt>
<dd><p>interpolate data values given axis values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>return_func</strong> (<em>boolean</em>) – defaults to False.  If True, it returns a function that accepts
axis values and returns a data value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.invinterp">
<code class="sig-name descname">invinterp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">values</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.invinterp" title="Permalink to this definition">¶</a></dt>
<dd><p>interpolate axis values given data values</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.item">
<code class="sig-name descname">item</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.item" title="Permalink to this definition">¶</a></dt>
<dd><p>like numpy item – returns a number when zero-dimensional</p>
</dd></dl>

<dl class="py method">
<dt id="id2">
<code class="sig-name descname">labels</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#id2" title="Permalink to this definition">¶</a></dt>
<dd><p>label the dimensions, given in listofstrings with the axis labels given in listofaxes – listofaxes must be a numpy np.array;
you can pass either a dictionary or a axis name (string)/axis label (numpy np.array) pair</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.like">
<code class="sig-name descname">like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.like" title="Permalink to this definition">¶</a></dt>
<dd><p>provide “zeros_like” and “ones_like” functionality</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>float</em>) – 1 is “ones_like” 0 is “zeros_like”, etc.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.linear_shear">
<code class="sig-name descname">linear_shear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">along_axis</span></em>, <em class="sig-param"><span class="n">propto_axis</span></em>, <em class="sig-param"><span class="n">shear_amnt</span></em>, <em class="sig-param"><span class="n">zero_fill</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.linear_shear" title="Permalink to this definition">¶</a></dt>
<dd><p>the linear shear – see <cite>self.shear</cite> for documentation</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.matchdims">
<code class="sig-name descname">matchdims</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.matchdims" title="Permalink to this definition">¶</a></dt>
<dd><p>add any dimensions to self that are not present in other</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.matrices_3d">
<code class="sig-name descname">matrices_3d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">also1d</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">invert</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_dimsize</span><span class="o">=</span><span class="default_value">1024</span></em>, <em class="sig-param"><span class="n">downsample_self</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.matrices_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>returns X,Y,Z,x_axis,y_axis
matrices X,Y,Z, are suitable for a variety of mesh plotting, etc, routines
x_axis and y_axis are the x and y axes</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.mayavi_surf">
<code class="sig-name descname">mayavi_surf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mayavi_surf" title="Permalink to this definition">¶</a></dt>
<dd><p>use the mayavi surf function, assuming that we’ve already loaded mlab
during initialization</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the mean and (optionally) set the error to the standard deviation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>std</strong> (<em>bool</em>) – whether or not to return the standard deviation as an error</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.mean_all_but">
<code class="sig-name descname">mean_all_but</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">listofdims</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mean_all_but" title="Permalink to this definition">¶</a></dt>
<dd><p>take the mean over all dimensions not in the list</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.mean_weighted">
<code class="sig-name descname">mean_weighted</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axisname</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mean_weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>perform  the weighted mean along <cite>axisname</cite> (use $sigma$ from $sigma = $self.get_error() do generate $1/sigma$ weights)
for now, it clears the error of <cite>self</cite>, though it would be easy to calculate the new error, since everything is linear</p>
<p>unlike other functions, this creates working objects that are themselves nddata objects
this strategy is easier than coding out the raw numpy math, but probably less efficient</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.meshplot">
<code class="sig-name descname">meshplot</code><span class="sig-paren">(</span><em class="sig-param">stride=None</em>, <em class="sig-param">alpha=1.0</em>, <em class="sig-param">onlycolor=False</em>, <em class="sig-param">light=None</em>, <em class="sig-param">rotation=None</em>, <em class="sig-param">cmap=&lt;matplotlib.colors.LinearSegmentedColormap object&gt;</em>, <em class="sig-param">ax=None</em>, <em class="sig-param">invert=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.meshplot" title="Permalink to this definition">¶</a></dt>
<dd><p>takes both rotation and light as elevation, azimuth
only use the light kwarg to generate a black and white shading display</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.mkd">
<code class="sig-name descname">mkd</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">arg</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.mkd" title="Permalink to this definition">¶</a></dt>
<dd><p>make dictionary format</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.name">
<code class="sig-name descname">name</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">arg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.name" title="Permalink to this definition">¶</a></dt>
<dd><p>args:
.name(newname) –&gt; Name the object (for storage, etc)
.name() –&gt; Return the name</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.nnls">
<code class="sig-name descname">nnls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dimname</span></em>, <em class="sig-param"><span class="n">newaxis_dict</span></em>, <em class="sig-param"><span class="n">kernel_func</span></em>, <em class="sig-param"><span class="n">l</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.nnls" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform regularized non-negative least-squares “fit” on self.</p>
<p>Capable of solving for solution in 1 or 2 dimensions.</p>
<p>We seek to minimize
<span class="math notranslate nohighlight">\(Q = \| Ax - b \|_2 + \|\lambda x\|_2\)</span>
in order to obtain solution vector <span class="math notranslate nohighlight">\(x\)</span> subject to non-negativity constraint
given input matrix <span class="math notranslate nohighlight">\(A\)</span>, the kernel, and input vector <span class="math notranslate nohighlight">\(b\)</span>, the data.</p>
<p>The first term assesses agreement between the fit <span class="math notranslate nohighlight">\(Ax\)</span> and the data <span class="math notranslate nohighlight">\(b\)</span>,
and the second term accounts for noise with the regularization parameter <span class="math notranslate nohighlight">\(\lambda\)</span>
according to Tikhonov regularization.</p>
<p>To perform regularized minimization in 2 dimensions, set <cite>l</cite> to <a href="#id3"><span class="problematic" id="id4">:str:`BRD`</span></a> and provide a
tuple of parameters <a href="#id5"><span class="problematic" id="id6">:str:`dimname`</span></a>, <a href="#id7"><span class="problematic" id="id8">:nddata:`newaxis_dict`</span></a>, and <a href="#id9"><span class="problematic" id="id10">:function:`kernel_func`</span></a>.
Algorithm described in Venkataramanan et al. 2002 is performed which determines optimal <span class="math notranslate nohighlight">\(\lambda\)</span>
for the data (DOI:10.1109/78.995059).</p>
<p>See: <a class="reference external" href="https://en.wikipedia.org/wiki/Non-negative_least_squares">Wikipedia page on NNLS</a>,
<a class="reference external" href="https://en.wikipedia.org/wiki/Tikhonov_regularization">Wikipedia page on Tikhonov regularization</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dimname</strong> (<em>str</em>) – Name of the “data” dimension that is to be replaced by a
distribution (the “fit” dimension);
<em>e.g.</em> if you are regularizing a set of functions
<span class="math notranslate nohighlight">\(\np.exp(-\tau*R_1)\)</span>, then this is <span class="math notranslate nohighlight">\(\tau\)</span></p></li>
<li><p><strong>newaxis_dict</strong> (<em>dict</em><em> or </em><a class="reference internal" href="generated/pyspecdata.core.nddata.html#pyspecdata.core.nddata" title="pyspecdata.core.nddata"><em>nddata</em></a>) – a dictionary whose key is the name of the “fit” dimension
(<span class="math notranslate nohighlight">\(R_1\)</span> in the example above)
and whose value is an np.array with the new axis labels.
OR
this can be a 1D nddata
– if it has an axis, the axis will be used to create the
fit axis; if it has no axis, the data will be used</p></li>
<li><p><strong>kernel_func</strong> (<em>function</em>) – a function giving the kernel for the regularization.
The first argument is the “data” variable
and the second argument is the “fit” variable
(in the example above, this would be something like
<code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x,y:</span> <span class="pre">np.exp(-x*y)</span></code>)</p></li>
<li><p><strong>l</strong> (<em>double</em><em> (</em><em>default 0</em><em>) or </em><em>str</em>) – the regularization parameter
<span class="math notranslate nohighlight">\(lambda\)</span> – if this is set to 0, the algorithm reverts to
standard nnls.
If this is set to <a href="#id11"><span class="problematic" id="id12">:str:`BRD`</span></a>, then algorithm expects tuple of each parameter
described above in order to perform a 2-dimensional fit.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The regularized result.
For future use, both the kernel (as an nddata, in a property called
“nnls_kernel”) and the residual (as an nddata, in a property called
“nnls_residual”) are stored as properties of the nddata.
The regularized dimension is always last
(innermost).
If <a href="#id13"><span class="problematic" id="id14">:str:`BRD`</span></a> is specified, then the individual, uncompressed kernels <span class="math notranslate nohighlight">\(K_{1}\)</span> and <span class="math notranslate nohighlight">\(K_{2}\)</span> are returned as properties of the nddata “K1” and “K2” respectively. The number of singular values used to compressed each kernel is returned in properties of the nddata called, respectively, “s1” and “s2”.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.plot_labels">
<code class="sig-name descname">plot_labels</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">labels</span></em>, <em class="sig-param"><span class="n">fmt</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs_passed</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.plot_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>this only works for one axis now</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.polyfit">
<code class="sig-name descname">polyfit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">force_y_intercept</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.polyfit" title="Permalink to this definition">¶</a></dt>
<dd><p>polynomial fitting routine – return the coefficients and the fit
..note:</p>
<blockquote>
<div><p>later, should probably branch this off as a new type of fit class</p>
</div></blockquote>
<dl class="simple">
<dt>..warning:</dt><dd><p>for some reason, this version doesn’t use orthogonal polynomials,
as the numpy routine does – we had diagnosed and determined that
that creates noticeably different results, so fix that here.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (<em>str</em>) – name of the axis that you want to fit along
(not sure if this is currently tested for multi-dimensional data,
but the idea should be that multiple fits would be returned.)</p></li>
<li><p><strong>order</strong> (<em>int</em>) – the order of the polynomial to be fit</p></li>
<li><p><strong>force_y_intercept</strong> (<em>double</em><em> or </em><em>None</em>) – force the y intercept to a particular value (e.g. 0)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>c</strong> (<em>np.ndarray</em>) – a standard numpy np.array containing the coefficients (in ascending polynomial order)</p></li>
<li><p><strong>formult</strong> (<em>nddata</em>) – an nddata containing the result of the fit</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.random_mask">
<code class="sig-name descname">random_mask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axisname</span></em>, <em class="sig-param"><span class="n">threshold</span><span class="o">=</span><span class="default_value">0.36787944117144233</span></em>, <em class="sig-param"><span class="n">inversion</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.random_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>generate a random mask with about ‘threshold’ of the points thrown out</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.real">
<em class="property">property </em><code class="sig-name descname">real</code><a class="headerlink" href="#pyspecdata.nddata.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real component of the data</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.register_axis">
<code class="sig-name descname">register_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arg</span></em>, <em class="sig-param"><span class="n">nearest</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.register_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate the data so that the given axes are in register with a set of specified values. Does not change the spacing of the axis labels.</p>
<p>It finds the axis label position that is closest to the values given in <cite>arg</cite>, then interpolates (Fourier/sinc method) the data onto a new, slightly shifted, axis that passes exactly through the value given.
To do this, it uses
<a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.core.nddata.ft_clear_startpoints" title="pyspecdata.core.nddata.ft_clear_startpoints"><code class="xref py py-func docutils literal notranslate"><span class="pre">.ft_clear_startpoints()</span></code></a>
and uses
<a class="reference internal" href="auto_api/pyspecdata.html#pyspecdata.core.nddata.set_ft_prop" title="pyspecdata.core.nddata.set_ft_prop"><code class="xref py py-func docutils literal notranslate"><span class="pre">.set_ft_prop()</span></code></a>
to override the “not aliased” flag.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arg</strong> (<em>dict</em><em> (</em><em>key</em><em>,</em><em>value = str</em><em>,</em><em>double</em><em>)</em>) – A list of the dimensions that you want to place in register, and the values you want them registered to.</p></li>
<li><p><strong>nearest</strong> (<em>bool</em><em>, </em><em>optional</em>) – Passed through to ft_clear_startpoints</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.reorder">
<code class="sig-name descname">reorder</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">axes</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder the dimensions
the first arguments are a list of dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*axes</strong> (<em>str</em>) – Accept any number of arguments that gives the dimensions, in the
order that you want thee.</p></li>
<li><p><strong>first</strong> (<em>bool</em>) – (default True)
Put this list of dimensions first, while False puts them last (where they then come in the order given).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.run" title="Permalink to this definition">¶</a></dt>
<dd><p>run a standard numpy function on the nddata:</p>
<p><code class="docutils literal notranslate"><span class="pre">d.run(func,'axisname')</span></code> will run function <cite>func</cite> (<em>e.g.</em> a
lambda function) along axis named ‘axisname’</p>
<p><code class="docutils literal notranslate"><span class="pre">d.run(func)</span></code> will run function <cite>func</cite> on the data</p>
<p><strong>in general</strong>: if the result of func reduces a dimension size to
1, the ‘axisname’ dimension will be “popped” (it will not exist in
the result) – if this is not what you want, use <code class="docutils literal notranslate"><span class="pre">run_nopop</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.run_avg">
<code class="sig-name descname">run_avg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">thisaxisname</span></em>, <em class="sig-param"><span class="n">decimation</span><span class="o">=</span><span class="default_value">20</span></em>, <em class="sig-param"><span class="n">centered</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.run_avg" title="Permalink to this definition">¶</a></dt>
<dd><p>a simple running average</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.secsy_transform">
<code class="sig-name descname">secsy_transform</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">direct_dim</span></em>, <em class="sig-param"><span class="n">indirect_dim</span></em>, <em class="sig-param"><span class="n">has_indirect</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'fourier'</span></em>, <em class="sig-param"><span class="n">truncate</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.secsy_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the time-domain data backwards by the echo time.</p>
<p>As opposed to <a class="reference internal" href="auto_api/pyspecdata.axis_manipulation.html#pyspecdata.axis_manipulation.secsy_transform_manual" title="pyspecdata.axis_manipulation.secsy_transform_manual"><code class="xref py py-func docutils literal notranslate"><span class="pre">secsy_transform_manual</span></code></a>, this calls on on <code class="xref py py-func docutils literal notranslate"><span class="pre">skew</span></code>,
rather than directly manipulating the phase of the function, which can lead to aliasing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>has_indirect</strong> (<em>bool</em>) – <p>(This option is largely specific to data loaded by <code class="xref py py-func docutils literal notranslate"><span class="pre">acert_hdf5</span></code>)</p>
<p>Does the data actually have an indirect dimension?
If not, assume that there is a constant echo time,
that can be retrieved with <code class="docutils literal notranslate"><span class="pre">.get_prop('te')</span></code>.</p>
</p></li>
<li><p><strong>truncate</strong> (<em>bool</em>) – If this is set, <cite>register_axis &lt;pyspecdata.axis_manipulation.register_axis&gt;</cite> to <span class="math notranslate nohighlight">\(t_{direct}=0\)</span>,
and then throw out the data for which <span class="math notranslate nohighlight">\(t_{direct}&lt;0\)</span>.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – The shear method (linear or fourier).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.secsy_transform_manual">
<code class="sig-name descname">secsy_transform_manual</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">direct_dim</span></em>, <em class="sig-param"><span class="n">indirect_dim</span></em>, <em class="sig-param"><span class="n">has_indirect</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">truncate</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.secsy_transform_manual" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the time-domain data backwards by the echo time.
As opposed to <a class="reference internal" href="auto_api/pyspecdata.axis_manipulation.html#pyspecdata.axis_manipulation.secsy_transform" title="pyspecdata.axis_manipulation.secsy_transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">secsy_transform</span></code></a>, this directlly manipulates the phase of the function, rather than calling on <code class="xref py py-func docutils literal notranslate"><span class="pre">skew</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>has_indirect</strong> (<em>bool</em>) – <p>(This option is largely specific to data loaded by <code class="xref py py-func docutils literal notranslate"><span class="pre">acert_hdf5</span></code>)</p>
<p>Does the data actually have an indirect dimension?
If not, assume that there is a constant echo time,
that can be retrieved with <code class="docutils literal notranslate"><span class="pre">.get_prop('te')</span></code>.</p>
</p></li>
<li><p><strong>truncate</strong> (<em>bool</em>) – If this is set, <cite>register_axis &lt;pyspecdata.axis_manipulation.register_axis&gt;</cite> to <span class="math notranslate nohighlight">\(t_{direct}=0\)</span>,
and then throw out the data for which <span class="math notranslate nohighlight">\(t_{direct}&lt;0\)</span>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.set_error">
<code class="sig-name descname">set_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.set_error" title="Permalink to this definition">¶</a></dt>
<dd><p>set the errors: either</p>
<p><cite>set_error(‘axisname’,error_for_axis)</cite> or <cite>set_error(error_for_data)</cite></p>
<p><cite>error_for_data</cite> can be a scalar, in which case, <strong>all</strong> the data errors are set to <cite>error_for_data</cite></p>
<div class="admonition-todo admonition" id="id15">
<p class="admonition-title">Todo</p>
<p>several options below – enumerate them in the documentation</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.set_ft_prop">
<code class="sig-name descname">set_ft_prop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">propname</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.set_ft_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the FT property given by <cite>propname</cite>.  For both setting and getting, <cite>None</cite> is equivalent to an unset value if <cite>propname</cite> is a boolean, and <cite>value</cite> is True (the default), it’s assumed that propname is actually None, and that <cite>value</cite> is set to the <cite>propname</cite> argument (this allows us to set the <cite>FT</cite> property more easily)</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.set_prop">
<code class="sig-name descname">set_prop</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.set_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>set a ‘property’ of the nddata
This is where you can put all unstructured information (e.g. experimental parameters, etc)</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.set_to">
<code class="sig-name descname">set_to</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">otherinst</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.set_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Set data inside the current instance to that of the other instance.</p>
<p>Goes through the list of attributes specified in copy,
and assigns them to the element of the current instance.</p>
<p>This is to be used:</p>
<ul class="simple">
<li><p>for constructing classes that inherit nddata with additional methods.</p></li>
<li><p>for overwriting the current data with the result of a slicing operation</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.setaxis">
<code class="sig-name descname">setaxis</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.setaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>set or alter the value of the coordinate axis</p>
<p>Can be used in one of several ways:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self.setaxis('axisname',</span> <span class="pre">values)</span></code>: just sets the values</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">self.setaxis('axisname',</span> <span class="pre">'#')</span></code>: just</dt><dd><p>number the axis in numerically increasing order
(e.g. if you have smooshed it from a couple
other dimensions.)</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.fromaxis('axisname',inputfunc)</span></code>: take the existing function, apply inputfunc, and replace</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.fromaxis(inputsymbolic)</span></code>: Evaluate <cite>inputsymbolic</cite> and load the result into the axes, appropriately</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.shear">
<code class="sig-name descname">shear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">along_axis</span></em>, <em class="sig-param"><span class="n">propto_axis</span></em>, <em class="sig-param"><span class="n">shear_amnt</span></em>, <em class="sig-param"><span class="n">zero_fill</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">start_in_conj</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'linear'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.shear" title="Permalink to this definition">¶</a></dt>
<dd><p>Shear the data <span class="math notranslate nohighlight">\(s\)</span>:</p>
<p><span class="math notranslate nohighlight">\(s(x',y,z) = s(x+ay,y,z)\)</span></p>
<p>where <span class="math notranslate nohighlight">\(x\)</span> is the <cite>altered_axis</cite> and <span class="math notranslate nohighlight">\(y\)</span> is the
<cite>propto_axis</cite>.  (Actually typically 2D, but <span class="math notranslate nohighlight">\(z\)</span> included
just to illustrate other dimensions that aren’t involved)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>{'fourier'</em><em>,</em><em>'linear'}</em>) – <dl>
<dt>fourier</dt><dd><p>Use the Fourier shift theorem (<em>i.e.</em>, sinc interpolation).  A
shear is equivalent to the following in the conjugate domain:</p>
<p>..math: <cite>tilde{s}(f_x,f’_y,z) = tilde{s}(f_x,f_y-af_x,f_z)</cite></p>
<p>Because of this, the algorithm <strong>also</strong>
automatically <cite>extend`s the data in `f_y</cite> axis.
Equivalently, it increases the resolution
(decreases the interval between points) in the
<cite>propto_axis</cite> dimension.  This prevents aliasing
in the conjugate domain, which will corrupt the
data <em>w.r.t.</em> successive transformations. It does
this whether or not <cite>zero_fill</cite> is set
(<cite>zero_fill</cite> only controls filling in the
“current” dimension)</p>
</dd>
<dt>linear</dt><dd><p>Use simple linear interpolation.</p>
</dd>
</dl>
</p></li>
<li><p><strong>altered_axis</strong> (<em>str</em>) – The coordinate for which data is altered, <em>i.e.</em>
..math: <cite>x</cite> such that ..math: <cite>f(x+ay,y)</cite>.</p></li>
<li><p><strong>by_amount</strong> (<em>double</em>) – The amount of the shear (..math: <cite>a</cite> in the previous)</p></li>
<li><p><strong>propto_axis</strong> (<em>str</em>) – The shift along the <cite>altered_axis</cite> dimension is
proportional to the shift along <cite>propto_axis</cite>.
The position of data relative to the <cite>propto_axis</cite> is not
changed.
Note that by the shift theorem, in the frequency domain,
an equivalent magnitude, opposite sign, shear is applied
with the <cite>propto_axis</cite> and <cite>altered_axis</cite> dimensions
flipped.</p></li>
<li><p><strong>start_in_conj</strong> (<em>{False</em><em>, </em><em>True}</em><em>, </em><em>optional</em>) – <p>Defaults to False</p>
<p>For efficiency, one can replace a double (I)FT call followed by a
shear call with a single shear call where <cite>start_in_conj</cite> is set.</p>
<p><cite>self</cite> before the call is given in the conjugate domain  (<em>i.e.</em>,
<span class="math notranslate nohighlight">\(f\)</span> <em>vs.</em> <span class="math notranslate nohighlight">\(t\)</span>) along both dimensions from the one that’s
desired.  This means: (1) <cite>self</cite> after the function call transformed
into the conjugate domain from that before the call and (2)
<cite>by_amount</cite>, <cite>altered_axis</cite>, and <cite>propto_axis</cite> all refer to the shear
in the conjugate domain that the data is in at the end of the
function call.</p>
</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.smoosh">
<code class="sig-name descname">smoosh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dimstocollapse</span></em>, <em class="sig-param"><span class="n">dimname</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">noaxis</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.smoosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Collapse (smoosh) multiple dimensions into one dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dimstocollapse</strong> (<em>list of strings</em>) – the dimensions you want to collapse to one result dimension</p></li>
<li><p><strong>dimname</strong> (<em>None</em><em>, </em><em>string</em><em>, </em><em>integer</em><em> (</em><em>default 0</em><em>)</em>) – <p>if dimname is:</p>
<ul>
<li><p>None: create a new (direct product) name,</p></li>
<li><p>a number: an index to the <code class="docutils literal notranslate"><span class="pre">dimstocollapse</span></code> list.  The resulting smooshed dimension will be named <code class="docutils literal notranslate"><span class="pre">dimstocollapse[dimname]</span></code>. Because the default is the number 0, the new dimname will be the first dimname given in the list.</p></li>
<li><p>a string: the name of the resulting smooshed dimension (can be part of the <code class="docutils literal notranslate"><span class="pre">dimstocollapse</span></code> list or not)</p></li>
</ul>
</p></li>
<li><p><strong>noaxis</strong> (<em>bool</em>) – if set, then just skip calculating the axis for the new dimension,
which otherwise is typically a complicated record array</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>self</strong> (<em>nddata</em>) – the dimensions <cite>dimstocollapse</cite> are smooshed into a single dimension,
whose name is determined by <cite>dimname</cite>.
The axis for the resulting, smooshed dimension is a structured
np.array consisting of two fields that give the labels along the
original axes.</p></li>
<li><p><em>..todo::</em> – when we transition to axes that are stored using a
slice/linspace-like format,
allow for smooshing to determine a new axes that is standard
(not a structured np.array) and that increases linearly.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">return_dropped</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>squeeze singleton dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>return_dropped</strong> (<em>bool</em><em> (</em><em>default False</em><em>)</em>) – return a list of the dimensions that were dropped as a second argument</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>self</em></p></li>
<li><p><strong>return_dropped</strong> (<em>list</em>) – (optional, only if return_dropped is True)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.to_ppm">
<code class="sig-name descname">to_ppm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.to_ppm" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that converts from Hz to ppm using Bruker parameters</p>
<div class="admonition-todo admonition" id="id16">
<p class="admonition-title">Todo</p>
<p>Figure out what the units of PHC1 in Topspin are (degrees per <em>what??</em>), and apply those as well.</p>
<p>make this part of an inherited bruker class</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.unitify_axis">
<code class="sig-name descname">unitify_axis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis_name</span></em>, <em class="sig-param"><span class="n">is_axis</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.unitify_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>this just generates an axis label with appropriate units</p>
</dd></dl>

<dl class="py method">
<dt id="pyspecdata.nddata.unset_prop">
<code class="sig-name descname">unset_prop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">arg</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyspecdata.nddata.unset_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a ‘property’</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="axis_manipulation.html" class="btn btn-neutral float-right" title="Axis Manipulation Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="notebook.html" class="btn btn-neutral float-left" title="LaTeX Notebook Functionality" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2016, John M. Franck

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>